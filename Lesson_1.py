# -*- coding: utf-8 -*-
"""Копия 2.3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ckpt4Wdw_gzuF8bpy46rIZ-2QijoOxzY
"""

from math import factorial

print('Задание 1.')

# Из колоды в 52 карты извлекаются случайным образом 4 карты.
# a) Найти вероятность того, что все карты – крести.
# б) Найти вероятность, что среди 4-х карт окажется хотя бы один туз.

# а) Сначала устанавливаем количество карт крестовой масти:

crosses = 52 / 4
print('Количество карт крестовой масти:', crosses)

# Затем находим ответ через условную вероятность:

def cards_1(n, k):
  return (k/n) * ((k-1)/(n-1)) * ((k-2)/(n-2)) * ((k-3)/(n-3))

print('Вероятность, что 4 выбранные карты - крести:', "{:.4f}".format(cards_1(52, crosses)))

# б) Чтобы найти вероятность нахождения среди выбранных карт хотя бы одного туза
# находим разность количества возможных сочетаний с тузами и без тузов, а затем
# делим его на количество всех возможных сочетаний с тузами:

def cards_2(a, b):
# Количество всех возможных сочетаний с тузами:
  C1 = factorial(a)/(factorial(b) * factorial(a - b))
# Множество карт без тузов:
  substr_1 = a - b
# Все возможные сочетания из 4 карт без тузов:
  C0 = factorial(substr_1)/(factorial(b) * factorial(substr_1 - b))
# Все возможные сочетания с тузами:
  substr_2 = C1 - C0
# Количество всех возможных сочетаний с тузами:
  return substr_2/C1

print('Вероятность, что среди 4 карт будет не менее 1 туза:', "{:.2f}".format(cards_2(52, 4)))

print('Задание 2.')

# На входной двери подъезда установлен кодовый замок, содержащий десять кнопок с
# цифрами от 0 до 9. Код содержит три цифры, которые нужно нажать одновременно.
# Какова вероятность того, что человек, не знающий код, откроет дверь с первой
# попытки?

# Задачу можно решить методом комбинаторики, вычислив число возможных комбинаций:

def code(n, k):
  return (factorial(n))/(factorial(k)*(factorial(n - k)))

# Вероятность угадать код с первого раза будет равна единице, разделенной на
# число всех возможных комбинаций:

print('Количество возможных комбинаций кода:', code(10, 3))
print(f'Вероятность угадать код с первого раза: 1:{code(10, 3)}')

print('Задание 3.')

# В ящике имеется 15 деталей, из которых 9 окрашены. Рабочий случайным образом
# извлекает 3 детали. Какова вероятность того, что все извлеченные детали
# окрашены?

# Решение методом условной вероятности:

def detail(n, k):
  return (k/n) * ((k-1)/(n-1)) * ((k-2)/(n-2))

# Решение методом комбинаторики:

def detail_1(n, k, t):
  C1 = factorial(k)/(factorial(t) * factorial(k - t))
  C2 = factorial(n)/(factorial(t) * factorial(n - t))
  return C1/C2

print('Вероятность выбрать только окрашенные детали (решение по методу условной вероятности):', "{:.2f}".format(detail(15, 9)))
print('Вероятность выбрать только окрашенные детали (решение по методу комбинаторики):', "{:.2f}".format(detail_1(15, 9, 3)))

print('Задание 4.')

# В лотерее 100 билетов. Из них 2 выигрышных. Какова вероятность того, что 2
# приобретенных билета окажутся выигрышными?

# Решение методом условной вероятности:

def lottery(n, k):
  return (k/n) * ((k-1)/(n-1))

# Решение методом комбинаторики:

def lottery_1(n, k):
  C1 = factorial(k)/(factorial(k) * factorial(k - k))
  C2 = factorial(n)/(factorial(k) * factorial(n - k))
  return C1/C2

print('Вероятность выиграть лотерею:', "{:.4f}".format(lottery(100, 2)))
print('Вероятность выиграть лотерею:', "{:.4f}".format(lottery_1(100, 2)))